#!/usr/bin/env python
# -*- coding: UTF-8 -*-
"""
This is a package management system designed to work around packages
for the homedirectory.  The code is based upon ideas from GNU Stow.

HomeDir - manage the installation of packages for a user's homedir
Copyright (C) 2004-2006 by Christian Höltje

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
"""
import os, sys, traceback


## TODO
## * unmergeSubDir
## * detect conflicts from other packages (this might be done...)
## * copy the homedir.control into ~/.homedir/installed to allow the user
##   to know what was installed.  Note: it should work whether this info
##   is accurate or not

VERSION="0.1 keen beans"
IGNORE_DIRS=('.svn','CVS','RCS','.git')
STANDARDSVERSION = 1
COMMANDS = None # this is set below
HOME = os.path.expanduser("~/") # easy way to do it
HOMEDIR = os.path.expanduser("~/.homedir")
HOMEDIRCONFIG = os.path.join(HOMEDIR,"config")
CONTROLDIR = ".homedir"
CONTROLFILENAME = "control"

###
### Version Check
###
if sys.version_info >= (2,3):
    import optparse
if sys.version_info >= (2,2):
    try:
        import optparse
    except ImportError:
        try:
            import optik as optparse
        except ImportError:
            print >> sys.stderr, """This program will work with python2.2 if you have
the optik module installed.  You can get optik from
http://optik.sf.net/

Otherwise, please upgrade to python2.3"""
            sys.exit(1)
else:
    if '--python-retried' not in sys.argv:
        # This is a work around for older systems
        # that *have* python2.2 but it's not the default
        for path in os.getenv('PATH','').split(os.pathsep):
            for python in ('python2.4','python2.3','python2.2'):
                pythonpath = os.path.join(path,python)
                if os.path.exists(pythonpath):
                    argv = ['--'] +  sys.argv[:] + ['--python-retried']
                    os.execl(pythonpath, *argv)
        
    print >> sys.stderr, """This program requires either python 2.3 (or greater)
or python 2.2 with the optik module available at http://optik.sf.net/

You are running python %s""" % sys.version
    sys.exit(1)

# Remove this from the arguments. It's used to prevent an infinite
# loop and just confuses things if it is here.
if '--python-retried' in sys.argv:
    del sys.argv[sys.argv.index('--python-retried')]

# Error Classes
class NotPackageError(StandardError): pass
class ConflictError(StandardError):
    src = None
    dst = None
    def __init__(self,src,dst,*args):
        self.src = src
        self.dst = dst
        StandardError.__init__(self,*args)

    def __str__(self):
        src = self.src
        dst = self.dst
        return "The file %(dst)s prevents linking %(src)s" % locals()

# Debug Mode Helpers
DEBUG = False
def debug(*msg):
    "Either prints a debug message or is a nop, depending on options"
    if DEBUG:
        print "DEBUG: %s" % " ".join(map(str,msg))

DEBUG_FUNCTIONS = False
def fdebug(fname,locals=None):
    "print out the function call and args in a nice format"
    if DEBUG_FUNCTIONS:
        if locals:
            keys = locals.keys()
            keys.sort()
            args = " ".join(["%s==%s" % (key,locals[key]) for key in keys])
        else:
            args = ""
                
        print "   -> %s(%s)" % (fname, args)

# Warn mode helper
WARN = True
def warn(*msg):
    "Either prints a warning message or is a nop, depending on options"
    if WARN:
        print "WARN: %s" % " ".join(map(str,msg))

def pluralize(singular,plural,count):
    "Returns the correct form of a word, based on count"
    if count == 1:
        return singular
    elif count > 1:
        return plural
    else:
        raise AssertionError("Unable to pluralize")

class HDPackage(object):
    """HomeDir Package class.

    """
    package = None
    priority = None
    maintainer = None
    depends = None
    standards_version = None
    description = None
    dirs = None
    mkdirs = None

    package_location = None
    src_dirs = None
    src_mkdirs = None
    reverse_depends = None

    conflict_resolver = None

    _attributes = ('package','priority','maintainer','depends',
                   'standards-version','description','dirs','mkdirs',
                   'ubuntu-packages')

    def __init__(self, directory):
        self.package_location = os.path.realpath(directory)
        control = os.path.join(directory,CONTROLDIR,CONTROLFILENAME)
        if not os.path.exists(control):
            raise NotPackageError("No control file")
        self._parse(control)

    def __repr__(self):
        return "<%s %s>" % (self.__class__.__name__,
                            self.package)

    def __eq__(self,other):
        if isinstance(other,self.__class__):
            return self.package_location == other.package_location
      	elif isinstance(other,str):
	    return self.package == other
        else:
            raise TypeError( "%s cannot be compared to %s" % (
                self.__class__, type(other)))

    def _parse(self,control):
        curr = None
        fp = file(control,'r')
        num = 0
        for line in fp.readlines():
            num += 1
            line = line.rstrip()
            sline = line.strip()
            # Empty line, interrupts a list
            if sline == '':
                curr = None
                continue
            # Comments are ignored
            if sline.startswith('#') or sline.startswith(';'):
                continue
            if curr and \
               ( line.startswith(' ') or line.startswith('\t') ):
                self._attribute_append(curr,line,control,num)
                continue

            try:
                # Try to see if it's an attribute
                parts = line.split(':',1)
                if len(parts) > 1:
                    attribute,value = parts
                    value.rstrip()
                else:
                    attribute = parts[0]
                    value = None
            except ValueError:
                print >> sys.stderr, "Invalid control file: %s:%d" % (control,num)
                sys.exit(1)

            if attribute not in self._attributes:
                print >> sys.stderr, "Invalid attribute '%s' in control file:\n\t%s:%d" % (
                    attribute,control,num)
                sys.exit(1)
            self._attribute_set(attribute,value,control,num)
            curr = attribute

        # Validate the mkdirs -- must be in dirs
        if self.mkdirs and self.dirs:
            for mkdir in self.mkdirs:
                if mkdir not in self.dirs:
                    print >> sys.stderr, \
                          "Invalid mkdir: '%s' isn't marked as a dir" % \
                          mkdir
                    sys.exit(1)

        # List of real locations for the dirs in src
        src_dirs = self.src_dirs = []
        if self.dirs:
            for directory in self.dirs:
                src_dirs.append(os.path.join(self.package_location,directory))

        # List of real locations of diretories to make in src
        src_mkdirs = self.src_mkdirs = []
        if self.mkdirs:
            for mkdir in self.mkdirs:
                src_mkdirs.append(os.path.join(self.package_location,mkdir))

    def _attribute_set(self,attr,val,file,linenum):
        "Internal Method to set an attribute"
        if attr in ('mkdirs','dirs'):
            if val.strip():
                print >> sys.stderr, "%s start on the next line: %s:%d" % (
                    attr, file,linenum)
                sys.exit(1)
            setattr(self,attr, [])
        elif attr == "depends":
            d = self.depends = []
            d.extend( [x.strip() for x in val.split(',') if x] )
        elif attr == 'standards-version':
            val = int(val)
            if val != STANDARDSVERSION:
                raise NotPackageError("Invalid control file version: %s" % file)
            self.standard_version = val
        elif attr in self._attributes:
            setattr( self, attr, val.strip() )
        else:
            raise AssertionError("Invalid Attribute %s: %s:%d" % (attr,file,linenum))

    def _attribute_append(self,attr,val,file,linenum):
        "Internal Method to correct append to an attribute"
        if attr in ('mkdirs','dirs'):
            getattr(self,attr).append(val.strip())
        elif attr == "depends":
            d = self.depends
            d.extend( [x.strip() for x in val.split(',')] )
        elif attr == 'standards-version':
            raise AssertionError("Can't append %s" % attr)
        elif attr in self._attributes:
            setattr(self, attr, getattr(self,attr) + '\n' + val.rstrip())
        else:
            raise AssertionError("Invalid Attribute %s: %s:%d" % (attr,file,linenum))

    def _resolveConflict(self,src,dst):
        success = False
        if self.conflict_resolver:
            return self.conflict_resolver(src,dst)
        else:
            raise ConflictError(src=src, dst=dst)

    def unsymlink(self,file):
        "Helper method to remove a symlink and only symlinks"
        fdebug('%s.unsymlink' % self.package,
               {'file':file})
        if os.path.islink(file):
            os.unlink(file)
        elif os.path.exists(file):
            raise AssertionError("%s is not a symlink" % file)
        # else: It must not exist!

    def symlink(self, src, dest):
        "Perform a relative symlink"
        fdebug('%s.symlink' % self.package,
               {'src':src,
                'dest':dest})
        def split(path):
            "Splits apart the path into single directory components"
            parts = []
            parent, child = os.path.split(path)
            while child != '':
                parts.insert(0,child)
                parent, child = os.path.split(parent)
            return parts
            
        # To be user friendly, we'll keep the case here
        srclist = split(os.path.abspath(src))
        destlist = split(os.path.abspath(dest))

        while srclist[0] == destlist[0]:
            # Remove matching parts from the start of the path
            srclist.pop(0)
            destlist.pop(0)

        if len(destlist) >= 2:
            for i in range(0,len(destlist)-1):
                srclist.insert(0,os.pardir)

        os.symlink(os.path.join(*srclist),
                   dest)

    def short_description():
        doc = "Just the first line of the description"
        def fget(self):
            desc = self.description
            if desc:
                return desc.split('\n')[0]
            else:
                return "No Description"
        fset = fdel = None
        return locals()
    short_description = property(**short_description())

    def fromSubdir(cls,directory):
        "Classmethod: Create a package from a subdirectory"
        if os.path.exists(os.path.join(directory,CONTROLDIR,CONTROLFILENAME)):
            return cls(directory)
        updir = os.path.dirname(directory).rstrip(os.sep)
        if updir:
            return cls.fromSubdir(updir)
        else:
            return None
    fromSubdir = classmethod(fromSubdir)
            

    def merge(self,dest,src=None):
        "Merge the package into dest"
        fdebug('merge',locals())
        ignore_control = src is None
        if src is None:
            src = self.package_location
        dest = os.path.realpath(dest)
        for content in os.listdir(src):
            if content in IGNORE_DIRS:
                continue
            if ignore_control and content == CONTROLDIR:
                continue
            if os.path.isdir(os.path.join(src,content)):
                self.mergeSubDir(src,dest,content)
            else:
                self.mergeNonDir(src,dest,content)

    def isWithinLocation(self, path):
        "Returns true if path is within our package location"
        loc = "%s%s" % (self.package_location.rstrip(os.sep),os.sep)
        return path.startswith(loc)

    def mergeSubDir(self,src,dest,content):
        "Merge the subdirectory content from src to dest"
        fdebug('mergeSubDir',locals())
        destpath = os.path.join(dest,content)
        srcpath = os.path.join(src,content)
        if srcpath not in self.src_dirs:
            return # We skip stuff not in directories
        if srcpath in self.src_mkdirs and \
           not os.path.exists(destpath):
            os.mkdir(destpath)
        if os.path.islink( destpath ):
            linkpath = os.path.realpath( destpath )
            if self.isWithinLocation(linkpath):
                # This is fine.  The link is actually one of ours.
                # Nuke it to make sure it's correct
                self.unsymlink(destpath)
                self.symlink(srcpath,destpath)
            elif os.path.exists(destpath):
                if linkpath == srcpath:
                    warn( "%s already points to %s" % (destpath,
                                                       srcpath) )
                    return
                if os.path.isdir(srcpath):
                    other = self.__class__.fromSubdir(linkpath)
                    if not other:
                        if self._resolveConflict(src=srcpath,
                                                 dst=destpath):
                            # Retry after the resolve
                            self.mergeSubDir(src,dest,content)
                    else:
                        debug("%s splitting with %s" % (self, other))
                        self.unsymlink(destpath)
                        os.mkdir(destpath)
                        self.merge(src=srcpath,dest=destpath)
                        other.merge(src=linkpath,dest=destpath)
                else:
                    raise AssertionError("Untested path")
                    self._resolveConflict(src=srcpath, dst=destpath)
            else:
                if self._resolveConflict(src=srcpath, dst=destpath):
                    self.unsymlink(destpath)
                    self.symlink(srcpath,destpath)
        elif os.path.exists(destpath):
            if os.path.isdir(destpath):
                self.merge(src=srcpath,dest=destpath)
            else:
                if self._resolveConflict(src=srcpath, dst=destpath):
                    self.symlink(srcpath,destpath)
                # else keep on trucking.
        else:
            self.symlink(srcpath,destpath)


    def mergeNonDir(self, src, dest, content):
        fdebug('mergeNonDir',locals())
        # src is the stow directory we're merging from
        srcpath = os.path.join( src, content )
        # dest is the target directory that we are dropping
        # symlinks into
        destpath = os.path.join( dest, content )

        if os.path.islink(destpath):
            linkpath = os.path.realpath( destpath )
            if os.path.exists(linkpath):
                if self.isWithinLocation(linkpath):
                    warn( "%s already points to %s" % (destpath,
                                                       srcpath) )
                else:
                    if self._resolveConflict(src=srcpath,
                                             dst=destpath):
                        self.symlink(srcpath,destpath)
            else:
                # It's a broken symlink and safe to nuke it (yes?)
                self.unsymlink(destpath)
                self.symlink(srcpath,destpath)
        elif os.path.exists(destpath):
            if self._resolveConflict(src=srcpath, dst=destpath):
                self.symlink(srcpath,destpath)
            # otherwise, we're skipping the conflict
        else:
            self.symlink(srcpath,destpath)

    def unmerge(self,dest,only_dirs=None):
        "Unmerge the package from dest"
        fdebug('unmerge',locals())

        dest = os.path.realpath(dest)

        # We only check these dirs
        if only_dirs is None:
            only_dirs = [dest]
            if self.dirs:
                for directory in self.dirs:
                    only_dirs.append(os.path.join(dest,directory))
                
        elif dest not in only_dirs:
            # It's not prunable, don't worry about it.
            return False 
            
        if dest == self.package_location:
            return False # It's not empty

        is_empty = True
        for content in os.listdir(dest):
            destpath = os.path.join(dest,content)
            if os.path.islink(destpath):
                linktarget = os.path.realpath(destpath)
                if linktarget.startswith(self.package_location):
                    self.unsymlink(destpath)
                else:
                    is_empty = False
            elif os.path.isdir(destpath):
                is_destpath_empty = self.unmerge(destpath,only_dirs)
                is_empty = is_destpath_empty and is_empty
            else:
                is_empty = False

        if is_empty:
            try:
                os.rmdir(dest)
            except:                
                tb = traceback.format_exception( *sys.exc_info() )
                [debug(x) for x in "".join(tb).split('\n')]
                print >> sys.stderr, "Unable to remove directory %s:\n %s" % (
                    dest,tb[-1].rstrip())

        return is_empty

    def install(self,dest,src=None):
        "Install the package"
        fdebug('install',locals())
        _src = src
        if _src is None:
            _src = self.package_location
        preflight = os.path.join(_src,CONTROLDIR,'pre-install');
        if os.access(preflight, os.X_OK):
            os.system(preflight)
        self.merge(dest,src)
        postflight = os.path.join(_src,CONTROLDIR,'post-install');
        if os.access(postflight, os.X_OK):
            os.system(postflight)

    def remove(self,dest,src=None):
        "Remove the package"
        fdebug('remove',locals())
        _src = src
        if _src is None:
            _src = self.package_location
        preflight = os.path.join(_src,CONTROLDIR,'pre-remove');
        if os.access(preflight, os.X_OK):
            os.system(preflight)
        self.unmerge(dest,src)
        postflight = os.path.join(_src,CONTROLDIR,'post-remove');
        if os.access(postflight, os.X_OK):
            os.system(postflight)

def doParse():
    """Actually does the command line parsing.
    Returns (options, args) (as per optparse's parse_args
    """
    usage = """%prog [options] <command> arg(s)

commands:
  install               Install a package
  remove                Uninstall a package
  upgrade               Upgrade your installed packages (reinstall)
  list                  List all packages
  sync                  Use synccmd to syncronize the repository"""
    parser = optparse.OptionParser(version=VERSION, usage=usage)

    parser.add_option("-c","--config",
                      action="store", dest="config",
                      default=HOMEDIRCONFIG,
                      help="User configuration file")
    parser.add_option('-q','--quiet',
                      action="store_true", dest="quiet",
                      default=False,
                      help="Run without warnings and messages. Errors are still shown.")
##     parser.add_option('-n','--dry-run',
##                       action="store_true", dest="dry_run",
##                       default=False,
##                       help="Show the actions that would have been taken, "
##                       "but don't actually do them")
    parser.add_option('-d','--debug',
                      action="store_true", dest="debug",
                      default=False,
                      help="Turn on debugging info")
    parser.add_option('-D','--debug-functions',
                      action="store_true", dest="debug_functions",
                      default=False,
                      help="Turn on debugging info")
    parser.add_option('-s','--sync',
                      action="store_true", dest="do_sync",
                      default=False,
                      help="Do a sync prior to executing a command")

    (options,args) = parser.parse_args()

    global DEBUG,DEBUG_FUNCTIONS,WARN
    DEBUG=options.debug
    DEBUG_FUNCTIONS=options.debug_functions
    WARN=options.debug

    packagedirs = options.packagedirs = []
    options.synccmd = 'echo No synccmd defined'
    # Setup the config file
    try:
        fp = file(os.path.expanduser(options.config),'r')
        num = 0
        for line in fp.readlines():
            num+=1
            line = line.strip()
            if line == '' or line.startswith('#') or line.startswith(';'):
                continue
            try:
                var,val = line.split('=',1)
            except ValueError:
                print >> sys.stderr, "%s:%d  syntax error:\n%s" % (options.config,
                                                                   num,line)
                sys.exit(1)
            var = var.strip().lower()
            val = val.strip()
            if var == 'packages':
                if os.path.isdir(fixDir(val)):
                    packagedirs.append( val )
                elif not options.quiet:
                    print >> sys.stderr, "%s:%d  " %(options.config,num) + \
                          "ignoring packages directory '%s': does not exist" % val
            elif var == 'synccmd':
                options.synccmd = os.path.expanduser(os.path.expandvars(val))
            else:
                print >> sys.stderr, "%s:%d  invalid variable: '%s'" % (options.config,
                                                                        num, var)
                sys.exit(1)
        fp.close()
        if not packagedirs:
            raise IOError("No package directives found")
    except IOError,err:
        example = [
            '# Comments begin with pound signs',
            '# You may put as many package directory lines as you want',
            'packages = ~/files/homedir/packages',
            'packages = ~/files/homedir/personal',
            ]
        if options.config == HOMEDIRCONFIG and \
           not os.path.exists(HOMEDIRCONFIG):
            try:
                # Make this to make like easier
                try:
                    os.mkdir(os.path.dirname(HOMEDIRCONFIG))
                except:
                    pass
                fp = file(HOMEDIRCONFIG,'w')
                fp.write("# This is the homedir config file.\n#\n")
                fp.write( "".join( ["# %s\n" % x for x in example] ) )
                fp.write( "#\n" )
                fp.close

            except 'fish':
                pass

                   
        print >> sys.stderr, "%s: %s" % (err.args[-1],options.config)
        print >> sys.stderr, """
Example config file:
-------------------8<--------cut-------->8-------------------
%s
-------------------8<--------cut-------->8-------------------
""" % \
            "\n".join( example )
        parser.print_help()
        sys.exit(1)

    if not args:
        parser.print_help()
        sys.exit(0)
    if args[0] not in COMMANDS.keys():
        parser.error("Invalid command '%s'" % args[0])
    
    return options,args

def fixDir(dir):
    "expands variables, deals with ~/, fixes case, and removes double slashes"
    return os.path.expanduser(
        os.path.expandvars(
        os.path.normpath(
        os.path.normcase(
        dir
        ))))

def scanPackages(options):
    """Scan all the package directories, building up a list of packages
    """
    fdebug("scanPackages",locals())
    packages = options.packages = {}
    locations = options.package_locations = {}
    for topdir in options.packagedirs:
        topdir = fixDir(topdir)
        for pdir in os.listdir(topdir):
            ppath = os.path.join(topdir,pdir)
            if os.path.isdir(ppath):
                if pdir in IGNORE_DIRS:
                    continue
                try:
                    package = HDPackage(ppath)
                except NotPackageError,err:
                    debug("Ignoring %s; %s" % (ppath,err))
                    continue
                packages[package.package] = package
                locations[package.package_location] = package

    if DEBUG:
        # Assertion - There should be no packages left that are strs
        for n,p in options.packages.items():
            if isinstance(p,str):
                raise AssertionError("%s is a string %s" % (n,p))

def lookUp(options,*names):
    """Look up one or more packages; one per string in names"""
    fdebug('lookUp',locals())
    packages = []
    bad = []
    for name in names:
        if isinstance(name,HDPackage) and \
           options.packages.has_key(name.package):
            if name not in packages:
                packages.append(name)
        elif options.packages.has_key(name):
            p = options.packages[name]
            if p not in packages:
                packages.append(p)
        else:
            bad.append(name)
    if bad:
        if options.debug:
            raise AssertionError( "Bad Packages: %s" % ",".join(map(str,bad)))
        print >> sys.stderr, "Unknown packages: %s" % (",".join(map(str,bad)))
        sys.exit(1)
    return packages

def lookUpOne(options,name):
    "look up just one name"
    fdebug('lookUpOne',locals())
    results = lookUp(options,name)
    if results:
        return results[0]
    else:
        return None

def scanDepends(options):
    for package in options.packages.values():
        if package.depends is None:
            continue
        package.depends = [lookUpOne(options,x) for x in package.depends]

def buildPackageDepends(package,depends=None,ignore=None):
    """ARGS:
    package -- package to find dependencies for
    depends -- packages that package depends on (needed for recursion)
    ignore  -- packages to ignore (they are being taken care of elsewhere)

    Returns depends"""
    fdebug('buildPackageDepends',locals())
    if depends is None:
        depends = []
    if package.depends:
        for p in package.depends:
            if p not in depends and \
               (not ignore or p not in ignore):
                depends.append(p)
            buildPackageDepends(p,depends,ignore)
    return depends

def buildDeps(options,*packages):
    "Build up all the dependencies"
    fdebug('buildDeps',locals())

    scanDepends(options)

    allpkgs = []
    for package in packages:
        buildPackageDepends(package,allpkgs,ignore=packages)
    return allpkgs

def scanReverseDepends(options):
    for depender in options.packages.values():
        if depender.depends is None:
            dependencies = []
        else:
            dependencies = depender.depends

        # Everyone depends on homedir
        if depender.package != 'homedir' and \
           not [x for x in dependencies if x == 'homedir']:
            dependencies.append('homedir')
        
        for dependee in dependencies:
            dependee = lookUpOne(options,dependee)
            if dependee.reverse_depends is None:
                dependee.reverse_depends = []
            if depender not in dependee.reverse_depends:
                dependee.reverse_depends.append( depender )

def buildPackageReverseDepends(package,reverses=None,ignore=None):
    fdebug('buildPackageReverseDepends',locals())
    if reverses is None:
        reverses = []
    if package.reverse_depends:
        for p in package.reverse_depends:
            if p not in reverses and \
               (not ignore or p not in ignore):
                reverses.append(p)
            buildPackageReverseDepends(p,reverses,ignore)
    return reverses

class resolveConflict:
    counter = 0
    def __call__(package, src, dst):
        "Ask the user to resolve any conflicts"
        if not package.counter:
            print "[conflict]"
        package.counter += 1

        legit_answers = ['x','c','d','s']

        # Information about the source
        src_display = None
        if os.path.isdir(src):
            src_display = "I want to replace it with a directory"
        elif os.path.exists(src):
            src_display = "I want to replace it with a file"


        # Possible move candidate
        dstmove = "%s.bak" % dst 
        if os.path.exists(dstmove):
            legit_answers.append('o')
        else:
            legit_answers.append('r')

        # Collect possible extra information
        dst_display = dst
        if os.path.isdir(dst):
            ftype = "dir"
        elif os.path.exists(dst):
            ftype = "file"
        else:
            ftype = "????"

        link_display = None
        if os.path.islink(dst):
            link_display = "The symlink points to '%s'" % os.readlink(dst)
            if os.path.exists(dst):
                link_display += " (a %s)." % ftype
                ftype = "symlink"
            else:
                ftype = "broken symlink"
                link_display += " which does not exist"

        answer = ''
        count = 0
        while answer not in legit_answers:
            count += 1
            if count > 20:
                print "...Skipping..."
                answer = 's'
                continue
            print " ","*"*40
            print "    CONFLICT: The %s '%s' is in the way." % (ftype,dst_display)
            if link_display:
                print "              %s" % link_display
            if src_display:
                print "              %s" % src_display
            print "    I can do the following:"
            print "       x - exit"
            print "       c - cancel package"
            print "       d - destroy the current file"
            print "       s - skip file"
            if 'r' in legit_answers:
                print "       r - rename '%s' to '%s'" % (dst,os.path.basename(dstmove))
            if 'o' in legit_answers:
                print "       o - rename '%s' to '%s', over-writing the existing .bak file" % (dst,os.path.basename(dstmove))
            print "    Your choice? [%s] " % "/".join(legit_answers),
            answer = sys.stdin.readline().strip().lower()

        if answer == 'x':
            print "Okay then, quitting..."
            sys.exit(0)
        elif answer == 'c':
            raise ConflictError(src=src, dst=dst)
        elif answer == 'd':
            if os.path.exists(dst):
                os.unlink(dst)
            return True
        elif answer == 's':
            return False
        elif answer == 'r':
            if os.path.exists(dstmove):
                raise ConflictError("A file has prevented backup %s"%dstmove,
                                    src=src, dst=dst)
            os.rename(dst,dstmove)
            return True
        elif answer == 'o':
            if os.path.exists(dstmove):
                os.unlink(dstmove)
            os.rename(dst,dstmove)
            return True
        else:
            raise AssertionError("The while loop should prevent this from ever happening.")
HDPackage.conflict_resolver = resolveConflict()

def actionLoop( func, action, packages ):
    for package in packages:
        try:
            package.conflict_resolver.counter = 0
            start = "%-60s" % ("    %s %s..." % (action,package.package))
            print start,
            func(package)
            if package.conflict_resolver.counter:
                print start,
            print "[ok]"
        except ConflictError,err:
            print "[incomplete]"
            print >> sys.stderr, "There was an unresolved conflict while %s '%s' on file:" % (action,package.package)
            print >> sys.stderr, "    %s" % err

def buildRDeps(options,*packages):
    "Build up all the reverse dependencies"
    fdebug('buildRDeps',locals())

    scanReverseDepends(options)

    allpkgs = []
    for package in packages:
        buildPackageReverseDepends(package,allpkgs,ignore=packages)
    return allpkgs

def do_list(options):
    "Do the list command"
    items = options.packages.items()
    items.sort( lambda a,b: cmp(a[0],b[0]) )
    max_name = reduce(lambda prev,next: max(prev,len(next[0])), items, 0)
    template = "%%-%ds  %%s" % max_name
    for key, pkg in items:
        print template % (pkg.package,
                          pkg.short_description)
    print " %d packages" % len(options.packages.keys())

def do_install(options,*packages):
    "Do the install command"
    # lookup the packages
    packages = lookUp(options,*packages)
    print
    print "You asked me to install %s:" % pluralize('this package',
                                                    'these packages',
                                                    len(packages))
    for p in packages:
        print "    %s \t%s" % (p.package,p.short_description)

    # Do dependencies
    extra = buildDeps(options,*packages)
    if extra:
        print
        print "I need to install the following extra %s to meet dependencies:"%\
              pluralize('package','packages',len(extra))
        for p in extra:
            print "    %s \t%s" % (p.package,p.short_description)
        print "Is that okay? [Y/n] ",
        response = sys.stdin.readline().strip()
        if response and response[0].upper() != 'Y':
            print "Okay then, quitting..."
            sys.exit(0)
    print "Installing Packages..."
    actionLoop( lambda p:p.install(HOME), 'installing', extra+packages )

def do_remove(options,*packages):
    "Do the uninstall command"
    # lookup the packages

    packages = lookUp(options,*packages)
    print
    print "You asked me to remove %s:" % pluralize('this package',
                                                   'these packages',
                                                   len(packages))
    for p in packages:
        print "    %s \t%s" % (p.package,p.short_description)

    extra = buildRDeps(options,*packages)

    if extra:
        print
        print "The following %s depend on the above %s and will be" % (
              pluralize('package','packages',len(extra)),
              pluralize('package','packages',len(packages)))
        print "removed if installed:"
        for p in extra:
            print "    %s \t%s" % (p.package,p.short_description)
        print "Is that okay? [y/N] ",
        response = sys.stdin.readline().strip()
        if not response or response[0].upper() == 'N':
            print "Okay then, quitting..."
            sys.exit(0)

    print "Removing Packages..."
        
    actionLoop( lambda p:p.remove(HOME), 'removing', extra+packages )

def do_upgrade(options,*packages):
    packages = lookUp(options,*packages)
    print
    print "You asked me to upgrade %s:" % pluralize('this package',
                                                    'these packages',
                                                    len(packages))

    for p in packages:
        print "    %s \t%s" % (p.package,p.short_description)

    extra = buildDeps(options,*packages)
    reverse_deps = []
    for package in buildRDeps(options,*packages):
        # don't duplicate packages, please!
        if package not in extra:
            reverse_deps.append( package )

    if extra:
        print
        print "The following %s have dependencies that interact with " %\
              pluralize('package','packages',len(extra))
        print "the above %s and will be upgraded as well:" % pluralize(
            'package','packages',len(packages))
        for p in extra:
            print "    %s \t%s" % (p.package,p.short_description)

    if reverse_deps:
        print
        print "You might need to re-install %s" % \
              pluralize('this package','these packages',len(reverse_deps)),
        print "manually afterwards:"
        for p in reverse_deps:
            print "    %s \t%s" % (p.package,p.short_description)

    if extra or reverse_deps:
        print
        print "Is that okay? [y/N] ",
        response = sys.stdin.readline().strip()
        if not response or response[0].upper() == 'N':
            print "Okay then, quitting..."
            sys.exit(0)

    print "Updating Packages..."

    # UnInstall Only
    actionLoop( lambda p:p.remove(HOME), 'removing', reverse_deps )
    def func(package):
        package.install(HOME)
        package.remove(HOME)
        
    actionLoop( func, 'upgrading', extra + packages )

def do_sync(options):
    debug("executing '%s' in %s" % (options.synccmd,
                                    os.getcwd()))
    os.system( options.synccmd )


COMMANDS = {'list': do_list,
            'install': do_install,
            'remove': do_remove,
            'upgrade': do_upgrade,
            'sync': do_sync,
            }

if "__main__" == __name__:
    try:
        options, args = doParse()
        command = args[0]
        rest_args = args[1:]
        if options.do_sync:
            if command == 'sync':
                warn("Ignoring silly request to sync prior to doing a sync")
            else:
                do_sync(options)
        scanPackages(options)

        COMMANDS[command](options,*rest_args)
    except KeyboardInterrupt:
        print >> sys.stderr, "\nUser Aborted",
        sys.exit(1)


# Local Variables:
# mode: python
# tab-width: 4
# indent-tabs-mode: nil
# End:
    
